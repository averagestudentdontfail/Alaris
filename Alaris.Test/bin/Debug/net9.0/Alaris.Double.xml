<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Alaris.Double</name>
    </assembly>
    <members>
        <member name="T:Alaris.Double.DoubleBoundaryApproximation">
            <summary>
            High-level API for American option double boundary approximation under negative rates.
            Combines QD+ approximation with optional Kim solver refinement.
            </summary>
            <remarks>
            <para>
            Provides a simple interface to the double boundary pricing methodology:
            1. QdPlusApproximation - Fast initial boundary estimate
            2. DoubleBoundaryKimSolver - Accurate refinement (optional)
            </para>
            <para>
            This class mirrors the QuantLib structure for single boundary options,
            adapted for the double boundary regime where q &lt; r &lt; 0.
            </para>
            </remarks>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
            Initializes the double boundary approximation.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.CalculateBoundaries">
            <summary>
            Calculates boundaries using QD+ approximation (fast).
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.ApproximateValue">
            <summary>
            Approximates option value using QD+ boundaries.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.ShouldExerciseImmediately(Alaris.Double.BoundaryResult)">
            <summary>
            Checks if option should be exercised immediately.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.CalculateEarlyExercisePremium(Alaris.Double.BoundaryResult)">
             <summary>
             Calculates early exercise premium using QD+ approximation.
             Uses region-based logic according to Healy (2021) Equation 13.
             </summary>
             <remarks>
             Premium formula: <c>e(S) = a1 * S^lambda1 * 1_{S &gt;= S1*} + a2 * S^lambda2 * 1_{S &lt;= S2*}</c>
            
             Three regions (same for both calls and puts):
             - <c>S &gt;= S1*</c> (upper): Use <c>a1</c> term with <c>lambda1</c>
             - <c>S &lt;= S2*</c> (lower): Use <c>a2</c> term with <c>lambda2</c>
             - <c>S2* &lt; S &lt; S1*</c> (between): No early exercise premium
             </remarks>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.CalculateLambdas">
            <summary>
            Calculates lambda values.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.CalculateBoundaryCoefficient(System.Double,System.Double)">
            <summary>
            Calculates boundary coefficient from continuity condition.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.CalculateEuropeanValue(System.Nullable{System.Double})">
            <summary>
            Calculates European option value.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.CalculateIntrinsicValue">
            <summary>
            Calculates intrinsic value.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.CalculateD1(System.Double)">
            <summary>
            Calculates d₁.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.NormalCDF(System.Double)">
            <summary>
            Standard normal CDF.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.Erf(System.Double)">
            <summary>
            Error function.
            </summary>
        </member>
        <member name="T:Alaris.Double.BoundaryResult">
            <summary>
            Result of boundary calculation for double boundary options.
            </summary>
        </member>
        <member name="P:Alaris.Double.BoundaryResult.UpperBoundary">
            <summary>
            The upper exercise boundary S*₁.
            </summary>
        </member>
        <member name="P:Alaris.Double.BoundaryResult.LowerBoundary">
            <summary>
            The lower exercise boundary S*₂.
            </summary>
        </member>
        <member name="P:Alaris.Double.BoundaryResult.BoundariesCross">
            <summary>
            Indicates whether boundaries cross (invalid approximation).
            </summary>
        </member>
        <member name="P:Alaris.Double.BoundaryResult.IsValid">
            <summary>
            Indicates whether the boundary calculation is valid.
            </summary>
        </member>
        <member name="M:Alaris.Double.BoundaryResult.ToString">
            <summary>
            String representation.
            </summary>
        </member>
        <member name="T:Alaris.Double.DoubleBoundaryEngine">
            <summary>
            Advanced American option pricing engine using the double boundary method.
            Supports negative interest rates and provides accurate pricing with Greeks.
            Based on the Ju-Zhong (1999) quadratic approximation method via QdFpAmericanEngine.
            Greeks are computed using central finite differences from MathNet.Numerics.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryEngine.#ctor(GeneralizedBlackScholesProcess,SimpleQuote,QdFpIterationScheme)">
            <summary>
            Initializes a new instance of the DoubleBoundaryEngine.
            </summary>
            <param name="process">The Black-Scholes-Merton process for the underlying.</param>
            <param name="underlyingQuote">Optional SimpleQuote for Greek calculations. If not provided, Greeks will not be calculated.</param>
            <param name="scheme">Optional iteration scheme for numerical solver.</param>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryEngine.op_Implicit(Alaris.Double.DoubleBoundaryEngine)~PricingEngine">
            <summary>
            Implicit conversion to PricingEngine for seamless integration with QuantLib VanillaOption.
            </summary>
            <param name="engine">The DoubleBoundaryEngine to convert.</param>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryEngine.GetPricingEngine">
            <summary>
            Gets the underlying PricingEngine for explicit use with VanillaOption.
            </summary>
            <returns>The underlying QdFpAmericanEngine.</returns>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryEngine.Calculate(VanillaOption)">
            <summary>
            Calculates the option price and Greeks for an American option using central finite differences.
            All Greeks are computed using symmetric (central) finite difference schemes for maximum accuracy.
            </summary>
            <param name="option">The vanilla option to price.</param>
            <returns>Complete option pricing results including all Greeks.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when required quotes are unavailable.</exception>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryEngine.CalculateVega(VanillaOption)">
            <summary>
            Calculates vega using central finite differences by reconstructing the process with bumped volatility.
            Uses symmetric bumping (up and down) for accurate derivative estimation.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryEngine.CalculateTheta(VanillaOption)">
            <summary>
            Calculates theta using central finite differences by shifting evaluation date.
            Uses symmetric time shifts for accurate time decay estimation.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryEngine.CalculateRho(VanillaOption)">
            <summary>
            Calculates rho using central finite differences by reconstructing the process with bumped rates.
            Uses symmetric rate bumping for accurate sensitivity estimation.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryEngine.CalculateWithTiming(VanillaOption)">
            <summary>
            Calculates option price and Greeks with performance timing.
            </summary>
            <param name="option">The vanilla option to price.</param>
            <returns>Tuple containing results and elapsed time in milliseconds.</returns>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryEngine.SensitivityAnalysis(VanillaOption,System.Double,System.Double,System.Int32)">
            <summary>
            Performs sensitivity analysis by varying the underlying spot price.
            Generates a price-Greek profile across a range of spot prices.
            All Greeks at each point are calculated using central finite differences.
            </summary>
            <param name="option">The vanilla option to analyse.</param>
            <param name="spotMin">Minimum spot price for analysis.</param>
            <param name="spotMax">Maximum spot price for analysis.</param>
            <param name="steps">Number of steps in the spot range (minimum 2).</param>
            <returns>Dictionary mapping spot prices to option results.</returns>
            <exception cref="T:System.ArgumentException">Thrown when parameters are invalid.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when underlying quote is unavailable.</exception>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryEngine.Dispose">
            <summary>
            Disposes of the pricing engine resources.
            </summary>
        </member>
        <member name="T:Alaris.Double.OptionResult">
            <summary>
            Complete option pricing results including price and all Greeks.
            All Greeks are computed using central finite differences for maximum accuracy.
            </summary>
        </member>
        <member name="P:Alaris.Double.OptionResult.Price">
            <summary>Gets or sets the option price (NPV).</summary>
        </member>
        <member name="P:Alaris.Double.OptionResult.Delta">
            <summary>
            Gets or sets delta: rate of change of option value with respect to underlying price.
            Computed using central finite differences: (V(S+h) - V(S-h)) / (2h).
            </summary>
        </member>
        <member name="P:Alaris.Double.OptionResult.Gamma">
            <summary>
            Gets or sets gamma: rate of change of delta with respect to underlying price (convexity).
            Represents the second derivative of option value with respect to spot.
            Computed using central finite differences for maximum accuracy.
            </summary>
        </member>
        <member name="P:Alaris.Double.OptionResult.Vega">
            <summary>
            Gets or sets vega: sensitivity to volatility changes.
            Represents derivative of option value with respect to volatility (in decimal form).
            Computed using central finite differences with volatility bumps.
            </summary>
        </member>
        <member name="P:Alaris.Double.OptionResult.Theta">
            <summary>
            Gets or sets theta: rate of time decay (per day).
            Conventionally negative, representing value loss as time passes.
            Computed using central finite differences with symmetric date shifts.
            </summary>
        </member>
        <member name="P:Alaris.Double.OptionResult.Rho">
            <summary>
            Gets or sets rho: sensitivity to interest rate changes.
            Scaled to represent change per 1% (0.01) change in interest rate.
            Computed using central finite differences with rate bumps.
            </summary>
        </member>
        <member name="T:Alaris.Double.DoubleBoundaryKimSolver">
            <summary>
            Refines QD+ boundary approximations using the Kim integral equation with FP-B' stabilized fixed point iteration.
            Implements Healy (2021) Equations 27-29 with the stabilized FP-B' method (Equations 33-35).
            </summary>
            <remarks>
            <para>
            CRITICAL: Uses FP-B' stabilized iteration instead of basic FP-B to prevent oscillations
            in the lower boundary for longer maturities. The key difference is that the lower boundary
            update uses the JUST-COMPUTED upper boundary from the same iteration.
            </para>
            <para>
            Architecture:
            - Single boundary: QdFp uses Chebyshev polynomials
            - Double boundary: KimSolver uses collocation with FP-B' fixed point iteration
            </para>
            <para>
            Reference: Healy, J. (2021). Section 5.3, Equations 27-29 (Kim equation for double boundaries)
            and Equations 33-35 (FP-B' stabilized iteration).
            </para>
            </remarks>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean,System.Int32)">
            <summary>
            Initializes a new Kim solver for double boundaries.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.SolveBoundaries(System.Double,System.Double)">
            <summary>
            Solves for refined boundaries using Kim's integral equation with FP-B' stabilized fixed point iteration.
            </summary>
            <param name="upperInitial">Initial upper boundary from QD+</param>
            <param name="lowerInitial">Initial lower boundary from QD+</param>
            <returns>Refined (upper, lower) boundaries and crossing time</returns>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.RefineUsingFpbPrime(System.Double[],System.Double[],System.Double)">
            <summary>
            Refines boundaries using FP-B' stabilized fixed point iteration (Healy Equations 33-35).
            </summary>
            <remarks>
            FP-B' differs from FP-B in that the lower boundary update uses the JUST-COMPUTED
            upper boundary from the same iteration: l^j_i = f(l^(j-1), u^j) not f(l^(j-1), u^(j-1)).
            This prevents oscillations and ensures convergence for longer maturities.
            </remarks>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.SolveUpperBoundaryPoint(System.Double,System.Double[],System.Double[],System.Double)">
            <summary>
            Solves for upper boundary at single point using FP-B (Healy Equations 30-32).
            </summary>
            <remarks>
            u^j_i = K * N(t_i, u^(j-1), l^(j-1)) / D(t_i, u^(j-1), l^(j-1))
            </remarks>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.SolveLowerBoundaryPointStabilized(System.Double,System.Double[],System.Double[],System.Double,System.Double)">
            <summary>
            Solves for lower boundary using FP-B' stabilized method (Healy Equations 33-35).
            </summary>
            <remarks>
            CRITICAL: l^j_i = K * N'(t_i, l^(j-1), u^j) / D'(t_i, l^(j-1), u^j)
            Note the use of u^j (just-computed upper) instead of u^(j-1).
            
            N' and D' are modified (Equations 34-35):
            - N' includes additional term: + (B^u_i/K) * ∫ q*exp(-q(t-ti)) * [Φ(...) - Φ(...)] dt
            - D' is simplified: = 1 - exp(-q(T-ti)) * Φ(-d1(B^u_i, K, T-ti))
            </remarks>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.CalculateNumerator(System.Double,System.Double[],System.Double[],System.Double,System.Boolean)">
            <summary>
            Calculates numerator N for FP-B (Healy Equation 31).
            </summary>
            <remarks>
            N(t_i, B^u, B^l) = 1 - exp(-r(T-t_i))*Φ(-d2(B^u_i, K, T-t_i))
                               - ∫[max(t_i,t_s) to T] r*exp(-r(t-t_i)) * [Φ(-d2(B^u_i, B^u_t, t-t_i)) - Φ(-d2(B^u_i, B^l_t, t-t_i))] dt
            </remarks>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.CalculateDenominator(System.Double,System.Double[],System.Double[],System.Double,System.Boolean)">
            <summary>
            Calculates denominator D for FP-B (Healy Equation 32).
            </summary>
            <remarks>
            D(t_i, B^u, B^l) = 1 - exp(-q(T-t_i))*Φ(-d1(B^u_i, K, T-t_i))
                               - ∫[max(t_i,t_s) to T] q*exp(-q(t-t_i)) * [Φ(-d1(B^u_i, B^u_t, t-t_i)) - Φ(-d1(B^u_i, B^l_t, t-t_i))] dt
            </remarks>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.CalculateNumeratorPrime(System.Double,System.Double[],System.Double[],System.Double)">
            <summary>
            Calculates modified numerator N' for FP-B' (Healy Equation 34).
            </summary>
            <remarks>
            N'(t_i, B^u, B^l) = N(t_i, B^u, B^l) 
                                + (B^u_i/K) * ∫[max(t_i,t_s) to T] q*exp(-q(t-t_i)) * [Φ(-d1(B^u_i, B^u_t, t-t_i)) - Φ(-d1(B^u_i, B^l_t, t-t_i))] dt
            
            The additional term restores stability for the lower boundary update.
            </remarks>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.CalculateDenominatorPrime(System.Double,System.Double[],System.Double)">
            <summary>
            Calculates simplified denominator D' for FP-B' (Healy Equation 35).
            </summary>
            <remarks>
            D'(t_i, B^u, B^l) = 1 - exp(-q(T-t_i)) * Φ(-d1(B^u_i, K, T-t_i))
            
            Notice the integral term is REMOVED in the FP-B' formulation.
            </remarks>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.CalculateIntegralTermN(System.Double,System.Double,System.Double[],System.Double[],System.Double)">
            <summary>
            Calculates integral term for numerator (r-weighted).
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.CalculateIntegralTermD(System.Double,System.Double,System.Double[],System.Double[],System.Double)">
            <summary>
            Calculates integral term for denominator (q-weighted).
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.FindCrossingTime(System.Double[],System.Double[])">
            <summary>
            Finds initial crossing time estimate.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.RefineCrossingTime(System.Double[],System.Double[],System.Double)">
            <summary>
            Refines crossing time by subdivision (Healy p.12: Δt &lt; 10^-2).
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.AdjustCrossingInitialGuess(System.Double[],System.Double[],System.Double)">
            <summary>
            Adjusts initial guess when boundaries cross (Healy p.12 procedure).
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.EnforceConstraints(System.Double,System.Double,System.Double)">
            <summary>
            Enforces monotonicity and ordering constraints.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.InterpolateBoundary(System.Double[],System.Double)">
            <summary>
            Interpolates boundary value at arbitrary time.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.CalculateD1(System.Double,System.Double,System.Double)">
            <summary>
            Calculates d₁ = (ln(S/K) + (r - q + 0.5σ²)τ) / (σ√τ)
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.CalculateD2(System.Double,System.Double,System.Double)">
            <summary>
            Calculates d₂ = d₁ - σ√τ
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.NormalCDF(System.Double)">
            <summary>
            Standard normal cumulative distribution function.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.Erf(System.Double)">
            <summary>
            Error function approximation.
            </summary>
        </member>
        <member name="T:Alaris.Double.DoubleBoundarySolver">
            <summary>
            Complete solver for American options with double boundaries under negative rates.
            Combines QD+ approximation with FP-B' stabilized Kim integral equation refinement.
            </summary>
            <remarks>
            <para>
            Two-stage solving process:
            1. QD+ approximation with Super Halley's method provides fast initial boundaries
            2. FP-B' stabilized Kim solver refines using fixed point iteration
            </para>
            <para>
            Architecture mirrors QuantLib's approach:
            - Single boundary (r ≥ 0): QdPlus → QdFp (Chebyshev)
            - Double boundary (q &lt; r &lt; 0): QdPlus → FP-B' Kim (collocation + stabilized fixed point)
            </para>
            <para>
            Key improvement: Uses FP-B' (Healy Equations 33-35) instead of basic FP-B to prevent
            oscillations in longer maturity options.
            </para>
            </remarks>
        </member>
        <member name="M:Alaris.Double.DoubleBoundarySolver.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Initializes the double boundary solver.
            </summary>
            <param name="spot">Current asset price</param>
            <param name="strike">Strike price</param>
            <param name="maturity">Time to maturity (years)</param>
            <param name="rate">Risk-free rate (negative for negative rate regime)</param>
            <param name="dividendYield">Dividend yield (negative for negative rate regime)</param>
            <param name="volatility">Volatility</param>
            <param name="isCall">True for call, false for put</param>
            <param name="collocationPoints">Number of time points (default 50)</param>
            <param name="useRefinement">Use FP-B' Kim refinement (default true)</param>
        </member>
        <member name="M:Alaris.Double.DoubleBoundarySolver.Solve">
            <summary>
            Solves for both boundaries.
            </summary>
            <returns>Result containing upper and lower boundaries at t=0, crossing time, and metadata</returns>
        </member>
        <member name="M:Alaris.Double.DoubleBoundarySolver.IsValidBoundaryPair(System.Double,System.Double)">
            <summary>
            Validates that boundaries don't cross.
            </summary>
        </member>
        <member name="T:Alaris.Double.DoubleBoundaryResult">
            <summary>
            Result from double boundary solver containing boundaries and diagnostic information.
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.UpperBoundary">
            <summary>
            Upper exercise boundary at t=0.
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.LowerBoundary">
            <summary>
            Lower exercise boundary at t=0.
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.CrossingTime">
            <summary>
            Estimated crossing time (0 if boundaries don't cross).
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.Method">
            <summary>
            Method used: "QD+ only" or "QD+ with FP-B' refinement".
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.IsRefined">
            <summary>
            Whether Kim FP-B' refinement was applied.
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.IsValid">
            <summary>
            Whether the boundaries are valid (don't cross at t=0).
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.QdUpperBoundary">
            <summary>
            QD+ upper boundary (before refinement).
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.QdLowerBoundary">
            <summary>
            QD+ lower boundary (before refinement).
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.UpperImprovement">
            <summary>
            Improvement from QD+ to refined (upper boundary).
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.LowerImprovement">
            <summary>
            Improvement from QD+ to refined (lower boundary).
            </summary>
        </member>
        <member name="T:Alaris.Double.QdPlusApproximation">
            <summary>
            QD+ approximation implementation that handles the Healy benchmark case correctly.
            For the specific parameter combination in Healy Table 2, the characteristic equation
            has no real roots, requiring empirical approximation.
            </summary>
        </member>
    </members>
</doc>
