// STUN001B.cs - Polygon-based universe selection using pre-generated files

using System;
using System.Collections.Generic;
// using System.IO; -- Using fully qualified names due to QuantConnect namespace conflict
using System.Globalization;
using System.Linq;
using System.Threading;
using QuantConnect;
using QuantConnect.Algorithm;
using QuantConnect.Algorithm.Framework.Selection;
using QuantConnect.Data.UniverseSelection;
using Microsoft.Extensions.Logging;
using Alaris.Infrastructure.Data.Provider;

namespace Alaris.Algorithm.Universe;

/// <summary>
/// Polygon-based universe selection model that uses pre-generated universe files.
/// Component ID: STUN001B (Alternative to STUN001A)
/// </summary>
/// <remarks>
/// <para>
/// This selector reads from universe files generated by 'alaris universe generate':
/// - Location: Alaris.Lean/Data/equity/usa/fundamental/coarse/{yyyyMMdd}.csv
/// - Format: symbolId,ticker,close,volume,dollarVolume
/// </para>
/// <para>
/// Use this selector when LEAN fundamental data is not available.
/// Run 'alaris universe generate' before backtesting to create the universe files.
/// </para>
/// </remarks>
public sealed class STUN001B : UniverseSelectionModel
{
    private readonly DTpr004A _earningsProvider;
    private readonly ILogger<STUN001B>? _logger;
    private readonly string _dataPath;
    
    // Atilgan (2014) parameters
    private readonly int _daysBeforeEarningsMin;
    private readonly int _daysBeforeEarningsMax;
    private readonly decimal _minimumDollarVolume;
    private readonly decimal _minimumPrice;
    private readonly int _maxSymbols;
    
    // Universe file cache
    private DateTime _lastUniverseDate;
    private List<UniverseEntry> _cachedUniverse = new();
    private HashSet<string> _cachedEarningsSymbols = new(StringComparer.OrdinalIgnoreCase);

    /// <summary>
    /// Initialises a new instance of the Polygon-based universe selection model.
    /// </summary>
    public STUN001B(
        DTpr004A earningsProvider,
        string dataPath,
        int daysBeforeEarningsMin = 5,
        int daysBeforeEarningsMax = 7,
        decimal minimumDollarVolume = 1_500_000m,
        decimal minimumPrice = 5.00m,
        int maxFinalSymbols = 50,
        ILogger<STUN001B>? logger = null)
    {
        _earningsProvider = earningsProvider
            ?? throw new ArgumentNullException(nameof(earningsProvider));
        _dataPath = dataPath ?? throw new ArgumentNullException(nameof(dataPath));
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(daysBeforeEarningsMin, nameof(daysBeforeEarningsMin));
        ArgumentOutOfRangeException.ThrowIfLessThan(daysBeforeEarningsMax, daysBeforeEarningsMin, nameof(daysBeforeEarningsMax));
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(minimumDollarVolume, nameof(minimumDollarVolume));
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(minimumPrice, nameof(minimumPrice));
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(maxFinalSymbols, nameof(maxFinalSymbols));
        _daysBeforeEarningsMin = daysBeforeEarningsMin;
        _daysBeforeEarningsMax = daysBeforeEarningsMax;
        _minimumDollarVolume = minimumDollarVolume;
        _minimumPrice = minimumPrice;
        _maxSymbols = maxFinalSymbols;
        _logger = logger;
    }

    /// <summary>
    /// Returns configuration summary for logging.
    /// </summary>
    public string GetConfigurationSummary()
    {
        return $"Polygon Universe Selector: Days before earnings: [{_daysBeforeEarningsMin}, {_daysBeforeEarningsMax}], " +
               $"Min volume: {_minimumDollarVolume:C0}, Min price: {_minimumPrice:C2}, " +
               $"Max symbols: {_maxSymbols}";
    }

    /// <summary>
    /// Creates universes for the algorithm.
    /// </summary>
    public override IEnumerable<QuantConnect.Data.UniverseSelection.Universe> CreateUniverses(QCAlgorithm algorithm)
    {
        yield return new ScheduledUniverse(
            algorithm.DateRules.EveryDay(),
            algorithm.TimeRules.At(0, 0),
            dateTime => SelectSymbols(algorithm, dateTime));
    }

    /// <summary>
    /// Selects symbols from the Polygon universe files.
    /// </summary>
    private IEnumerable<Symbol> SelectSymbols(QCAlgorithm algorithm, DateTime dateTime)
    {
        var date = dateTime.Date;

        // Load universe from file if needed
        if (_lastUniverseDate != date)
        {
            LoadUniverseForDate(algorithm, date);
            LoadEarningsSymbols(algorithm, date);
            _lastUniverseDate = date;
        }

        if (_cachedUniverse.Count == 0)
        {
            algorithm.Debug($"STUN001B: No universe data for {date:yyyy-MM-dd}");
            return Enumerable.Empty<Symbol>();
        }

        // Filter by earnings
        var withEarnings = _cachedUniverse
            .Where(u => _cachedEarningsSymbols.Contains(u.Ticker))
            .Take(_maxSymbols)
            .ToList();

        _logger?.LogInformation(
            "Universe selection for {Date}: {TotalCount} stocks → {EarningsCount} with earnings",
            date, _cachedUniverse.Count, withEarnings.Count);

        algorithm.Debug($"STUN001B: {date:yyyy-MM-dd} - {_cachedUniverse.Count} stocks → {withEarnings.Count} with earnings");

        return withEarnings
            .Select(u => {
                var equity = algorithm.AddEquity(u.Ticker, Resolution.Daily);
#pragma warning disable CS0618 // SetDataNormalizationMode is obsolete but required for options trading
                equity.SetDataNormalizationMode(DataNormalizationMode.Raw);
#pragma warning restore CS0618
                return equity.Symbol;
            });
    }

    /// <summary>
    /// Loads universe from pre-generated CSV file.
    /// </summary>
    private static readonly char[] Separators = new[] { ',', ';' };

    /// <summary>
    /// Loads universe from pre-generated CSV file or ALARIS_SESSION_SYMBOLS.
    /// </summary>
    private void LoadUniverseForDate(QCAlgorithm algorithm, DateTime date)
    {
        _cachedUniverse.Clear();

        // Check for static session symbols (Backtest Mode override)
        var sessionSymbols = Environment.GetEnvironmentVariable("ALARIS_SESSION_SYMBOLS");
        if (!string.IsNullOrEmpty(sessionSymbols))
        {
            algorithm.Debug("STUN001B: Using static session universe from environment");
            var tickers = sessionSymbols.Split(Separators, StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
            
            foreach (var ticker in tickers)
            {
                _cachedUniverse.Add(new UniverseEntry
                {
                    SymbolId = ticker,
                    Ticker = ticker.ToUpperInvariant(),
                    Close = 1000m, // Dummy high value to pass filter
                    Volume = 1_000_000,
                    DollarVolume = 100_000_000m // Dummy high value to pass filter
                });
            }
            
            // Session symbols are explicit; filters are not applied in this path.
            return;
        }

        var filePath = System.IO.Path.Combine(_dataPath, "equity", "usa", "fundamental", "coarse", $"{date:yyyyMMdd}.csv");

        if (!System.IO.File.Exists(filePath))
        {
            // Try to find the most recent available file
            var universeDir = System.IO.Path.Combine(_dataPath, "equity", "usa", "fundamental", "coarse");
            if (!System.IO.Directory.Exists(universeDir))
            {
                algorithm.Error($"STUN001B: Universe directory not found: {universeDir}");
                algorithm.Error("STUN001B: Run 'alaris universe generate' to create universe files");
                return;
            }

            var files = System.IO.Directory.GetFiles(universeDir, "*.csv")
                .OrderByDescending(f => f)
                .ToList();

            if (files.Count == 0)
            {
                algorithm.Error("STUN001B: No universe files found. Run 'alaris universe generate'");
                return;
            }

            // Find the most recent file before or on the date
            var targetDate = date.ToString("yyyyMMdd");
            filePath = files.FirstOrDefault(f => string.Compare(System.IO.Path.GetFileNameWithoutExtension(f), targetDate, StringComparison.Ordinal) <= 0)
                       ?? files.Last();

            algorithm.Debug($"STUN001B: Using universe file: {System.IO.Path.GetFileName(filePath)}");
        }

        try
        {
            var lines = System.IO.File.ReadAllLines(filePath);
            foreach (var line in lines)
            {
                var parts = line.Split(',');
                if (parts.Length >= 5)
                {
                    _cachedUniverse.Add(new UniverseEntry
                    {
                        SymbolId = parts[0],
                        Ticker = parts[1].ToUpperInvariant(),
                        Close = decimal.TryParse(parts[2], NumberStyles.Number, CultureInfo.InvariantCulture, out var c) ? c : 0,
                        Volume = double.TryParse(parts[3], NumberStyles.Float, CultureInfo.InvariantCulture, out var v) ? v : 0,
                        DollarVolume = decimal.TryParse(parts[4], NumberStyles.Number, CultureInfo.InvariantCulture, out var dv) ? dv : 0
                    });
                }
            }

            // Apply filters
            _cachedUniverse = _cachedUniverse
                .Where(u => u.Close >= _minimumPrice)
                .Where(u => u.DollarVolume >= _minimumDollarVolume)
                .OrderByDescending(u => u.DollarVolume)
                .ToList();

            algorithm.Debug($"STUN001B: Loaded {_cachedUniverse.Count} stocks from {System.IO.Path.GetFileName(filePath)}");
        }
        catch (Exception ex)
        {
            algorithm.Error($"STUN001B: Error reading universe file: {ex.Message}");
        }
    }

    /// <summary>
    /// Loads earnings symbols by querying SEC EDGAR for top universe stocks.
    /// For backtesting, we use historical 8-K filings (which IS what happened).
    /// SEC EDGAR stores actual filing dates, not future predictions.
    /// </summary>
    private void LoadEarningsSymbols(QCAlgorithm algorithm, DateTime date)
    {
        _cachedEarningsSymbols.Clear();

        try
        {
            // Target earnings window (5-7 days ahead of simulation date)
            var startDate = date.AddDays(_daysBeforeEarningsMin);
            var endDate = date.AddDays(_daysBeforeEarningsMax);

            algorithm.Debug($"STUN001B: Checking for earnings between {startDate:MM-dd} and {endDate:MM-dd}");

            // Use batch query instead of per-symbol loop (prevents 100+ API calls)
            var symbolsWithEarnings = _earningsProvider.GetSymbolsWithEarningsAsync(
                startDate, endDate, CancellationToken.None)
                .GetAwaiter().GetResult();

            // Filter to symbols in our universe
            var universeSet = new HashSet<string>(
                _cachedUniverse.Select(u => u.Ticker),
                StringComparer.OrdinalIgnoreCase);

            foreach (var symbol in symbolsWithEarnings)
            {
                if (universeSet.Contains(symbol))
                {
                    _cachedEarningsSymbols.Add(symbol.ToUpperInvariant());
                }
            }

            algorithm.Debug($"STUN001B: Found {_cachedEarningsSymbols.Count} symbols with earnings in {startDate:MM-dd} to {endDate:MM-dd}");
        }
        catch (Exception ex)
        {
            algorithm.Error($"STUN001B: Error querying earnings calendar: {ex.Message}");
        }
    }

    private sealed class UniverseEntry
    {
        public required string SymbolId { get; init; }
        public required string Ticker { get; init; }
        public decimal Close { get; init; }
        public double Volume { get; init; }
        public decimal DollarVolume { get; init; }
    }
}
