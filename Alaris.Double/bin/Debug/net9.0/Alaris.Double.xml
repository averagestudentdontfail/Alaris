<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Alaris.Double</name>
    </assembly>
    <members>
        <member name="T:Alaris.Double.DoubleBoundaryApproximation">
            <summary>
            High-level API for American option double boundary approximation under negative rates.
            Combines QD+ approximation with optional Kim solver refinement.
            </summary>
            <remarks>
            <para>
            Provides a simple interface to the double boundary pricing methodology:
            1. QdPlusApproximation - Fast initial boundary estimate
            2. DoubleBoundaryKimSolver - Accurate refinement (optional)
            </para>
            <para>
            This class mirrors the QuantLib structure for single boundary options,
            adapted for the double boundary regime where q &lt; r &lt; 0.
            </para>
            </remarks>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
            Initializes the double boundary approximation.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.CalculateBoundaries">
            <summary>
            Calculates boundaries using QD+ approximation (fast).
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.ApproximateValue">
            <summary>
            Approximates option value using QD+ boundaries.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.ShouldExerciseImmediately(Alaris.Double.BoundaryResult)">
            <summary>
            Checks if option should be exercised immediately.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.CalculateEarlyExercisePremium(Alaris.Double.BoundaryResult)">
             <summary>
             Calculates early exercise premium using QD+ approximation.
             Uses region-based logic according to Healy (2021) Equation 13.
             </summary>
             <remarks>
             Premium formula: <c>e(S) = a1 * S^lambda1 * 1_{S &gt;= S1*} + a2 * S^lambda2 * 1_{S &lt;= S2*}</c>
            
             Three regions (same for both calls and puts):
             - <c>S &gt;= S1*</c> (upper): Use <c>a1</c> term with <c>lambda1</c>
             - <c>S &lt;= S2*</c> (lower): Use <c>a2</c> term with <c>lambda2</c>
             - <c>S2* &lt; S &lt; S1*</c> (between): No early exercise premium
             </remarks>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.CalculateLambdas">
            <summary>
            Calculates lambda values.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.CalculateBoundaryCoefficient(System.Double,System.Double)">
            <summary>
            Calculates boundary coefficient from continuity condition.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.CalculateEuropeanValue(System.Nullable{System.Double})">
            <summary>
            Calculates European option value.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.CalculateIntrinsicValue">
            <summary>
            Calculates intrinsic value.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.CalculateD1(System.Double)">
            <summary>
            Calculates d₁.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.NormalCDF(System.Double)">
            <summary>
            Standard normal CDF.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryApproximation.Erf(System.Double)">
            <summary>
            Error function.
            </summary>
        </member>
        <member name="T:Alaris.Double.BoundaryResult">
            <summary>
            Result of boundary calculation for double boundary options.
            </summary>
        </member>
        <member name="P:Alaris.Double.BoundaryResult.UpperBoundary">
            <summary>
            The upper exercise boundary S*₁.
            </summary>
        </member>
        <member name="P:Alaris.Double.BoundaryResult.LowerBoundary">
            <summary>
            The lower exercise boundary S*₂.
            </summary>
        </member>
        <member name="P:Alaris.Double.BoundaryResult.BoundariesCross">
            <summary>
            Indicates whether boundaries cross (invalid approximation).
            </summary>
        </member>
        <member name="P:Alaris.Double.BoundaryResult.IsValid">
            <summary>
            Indicates whether the boundary calculation is valid.
            </summary>
        </member>
        <member name="M:Alaris.Double.BoundaryResult.ToString">
            <summary>
            String representation.
            </summary>
        </member>
        <member name="T:Alaris.Double.DoubleBoundaryEngine">
            <summary>
            Advanced American option pricing engine using the double boundary method.
            Supports negative interest rates and provides accurate pricing with Greeks.
            Based on the Ju-Zhong (1999) quadratic approximation method via QdFpAmericanEngine.
            Greeks are computed using central finite differences from MathNet.Numerics.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryEngine.#ctor(GeneralizedBlackScholesProcess,SimpleQuote,QdFpIterationScheme)">
            <summary>
            Initializes a new instance of the DoubleBoundaryEngine.
            </summary>
            <param name="process">The Black-Scholes-Merton process for the underlying.</param>
            <param name="underlyingQuote">Optional SimpleQuote for Greek calculations. If not provided, Greeks will not be calculated.</param>
            <param name="scheme">Optional iteration scheme for numerical solver.</param>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryEngine.op_Implicit(Alaris.Double.DoubleBoundaryEngine)~PricingEngine">
            <summary>
            Implicit conversion to PricingEngine for seamless integration with QuantLib VanillaOption.
            </summary>
            <param name="engine">The DoubleBoundaryEngine to convert.</param>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryEngine.GetPricingEngine">
            <summary>
            Gets the underlying PricingEngine for explicit use with VanillaOption.
            </summary>
            <returns>The underlying QdFpAmericanEngine.</returns>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryEngine.Calculate(VanillaOption)">
            <summary>
            Calculates the option price and Greeks for an American option using central finite differences.
            All Greeks are computed using symmetric (central) finite difference schemes for maximum accuracy.
            </summary>
            <param name="option">The vanilla option to price.</param>
            <returns>Complete option pricing results including all Greeks.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when required quotes are unavailable.</exception>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryEngine.CalculateVega(VanillaOption)">
            <summary>
            Calculates vega using central finite differences by reconstructing the process with bumped volatility.
            Uses symmetric bumping (up and down) for accurate derivative estimation.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryEngine.CalculateTheta(VanillaOption)">
            <summary>
            Calculates theta using central finite differences by shifting evaluation date.
            Uses symmetric time shifts for accurate time decay estimation.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryEngine.CalculateRho(VanillaOption)">
            <summary>
            Calculates rho using central finite differences by reconstructing the process with bumped rates.
            Uses symmetric rate bumping for accurate sensitivity estimation.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryEngine.CalculateWithTiming(VanillaOption)">
            <summary>
            Calculates option price and Greeks with performance timing.
            </summary>
            <param name="option">The vanilla option to price.</param>
            <returns>Tuple containing results and elapsed time in milliseconds.</returns>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryEngine.SensitivityAnalysis(VanillaOption,System.Double,System.Double,System.Int32)">
            <summary>
            Performs sensitivity analysis by varying the underlying spot price.
            Generates a price-Greek profile across a range of spot prices.
            All Greeks at each point are calculated using central finite differences.
            </summary>
            <param name="option">The vanilla option to analyse.</param>
            <param name="spotMin">Minimum spot price for analysis.</param>
            <param name="spotMax">Maximum spot price for analysis.</param>
            <param name="steps">Number of steps in the spot range (minimum 2).</param>
            <returns>Dictionary mapping spot prices to option results.</returns>
            <exception cref="T:System.ArgumentException">Thrown when parameters are invalid.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when underlying quote is unavailable.</exception>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryEngine.Dispose">
            <summary>
            Disposes of the pricing engine resources.
            </summary>
        </member>
        <member name="T:Alaris.Double.OptionResult">
            <summary>
            Complete option pricing results including price and all Greeks.
            All Greeks are computed using central finite differences for maximum accuracy.
            </summary>
        </member>
        <member name="P:Alaris.Double.OptionResult.Price">
            <summary>Gets or sets the option price (NPV).</summary>
        </member>
        <member name="P:Alaris.Double.OptionResult.Delta">
            <summary>
            Gets or sets delta: rate of change of option value with respect to underlying price.
            Computed using central finite differences: (V(S+h) - V(S-h)) / (2h).
            </summary>
        </member>
        <member name="P:Alaris.Double.OptionResult.Gamma">
            <summary>
            Gets or sets gamma: rate of change of delta with respect to underlying price (convexity).
            Represents the second derivative of option value with respect to spot.
            Computed using central finite differences for maximum accuracy.
            </summary>
        </member>
        <member name="P:Alaris.Double.OptionResult.Vega">
            <summary>
            Gets or sets vega: sensitivity to volatility changes.
            Represents derivative of option value with respect to volatility (in decimal form).
            Computed using central finite differences with volatility bumps.
            </summary>
        </member>
        <member name="P:Alaris.Double.OptionResult.Theta">
            <summary>
            Gets or sets theta: rate of time decay (per day).
            Conventionally negative, representing value loss as time passes.
            Computed using central finite differences with symmetric date shifts.
            </summary>
        </member>
        <member name="P:Alaris.Double.OptionResult.Rho">
            <summary>
            Gets or sets rho: sensitivity to interest rate changes.
            Scaled to represent change per 1% (0.01) change in interest rate.
            Computed using central finite differences with rate bumps.
            </summary>
        </member>
        <member name="T:Alaris.Double.DoubleBoundaryKimSolver">
            <summary>
            Refines QD+ boundary approximations using the Kim integral equation with FP-B' stabilized fixed point iteration.
            Implements Healy (2021) Equations 27-29 with the stabilized FP-B' method (Equations 33-35).
            </summary>
            <remarks>
            <para>
            CRITICAL: Uses FP-B' stabilized iteration instead of basic FP-B to prevent oscillations
            in the lower boundary for longer maturities. The key difference is that the lower boundary
            update uses the JUST-COMPUTED upper boundary from the same iteration.
            </para>
            <para>
            Architecture:
            - Single boundary: QdFp uses Chebyshev polynomials
            - Double boundary: KimSolver uses collocation with FP-B' fixed point iteration
            </para>
            <para>
            Reference: Healy, J. (2021). Section 5.3, Equations 27-29 (Kim equation for double boundaries)
            and Equations 33-35 (FP-B' stabilized iteration).
            </para>
            </remarks>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean,System.Int32)">
            <summary>
            Initializes a new Kim solver for double boundaries.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.SolveBoundaries(System.Double,System.Double)">
            <summary>
            Solves for refined boundaries using Kim's integral equation with FP-B' stabilized iteration.
            </summary>
            <param name="upperInitial">Initial upper boundary from QD+</param>
            <param name="lowerInitial">Initial lower boundary from QD+</param>
            <returns>Refined (upper, lower) boundaries and crossing time</returns>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.RefineUsingFpbPrime(System.Double[],System.Double[],System.Double)">
            <summary>
            Refines boundaries using FP-B' stabilized fixed point iteration (Healy Equations 33-35).
            </summary>
            <remarks>
            FP-B' differs from FP-B in that the lower boundary update uses the JUST-COMPUTED
            upper boundary from the same iteration: l^j_i = f(l^(j-1), u^j) not f(l^(j-1), u^(j-1)).
            This prevents oscillations and ensures convergence for longer maturities.
            </remarks>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.SolveUpperBoundaryPoint(System.Double,System.Double[],System.Double[],System.Double)">
            <summary>
            Solves for upper boundary at single point using FP-B (Healy Equations 30-32).
            </summary>
            <remarks>
            u^j_i = K * N(t_i, u^(j-1), l^(j-1)) / D(t_i, u^(j-1), l^(j-1))
            </remarks>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.SolveLowerBoundaryPointStabilized(System.Double,System.Double[],System.Double[],System.Double)">
            <summary>
            Solves for lower boundary using FP-B' stabilized method (Healy Equations 33-35).
            </summary>
            <remarks>
            CRITICAL: l^j_i = K * N'(t_i, l^(j-1), u^j) / D'(t_i, l^(j-1), u^j)
            Note the use of u^j (just-computed upper) instead of u^(j-1).
            </remarks>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.CalculateNumerator(System.Double,System.Double[],System.Double[],System.Double,System.Boolean)">
            <summary>
            Calculates numerator N for FP-B (Healy Equation 31).
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.CalculateDenominator(System.Double,System.Double[],System.Double[],System.Double,System.Boolean)">
            <summary>
            Calculates denominator D for FP-B (Healy Equation 32).
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.CalculateNumeratorPrime(System.Double,System.Double[],System.Double[],System.Double)">
            <summary>
            Calculates modified numerator N' for FP-B' (Healy Equation 34).
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.CalculateDenominatorPrime(System.Double,System.Double[],System.Double)">
            <summary>
            Calculates simplified denominator D' for FP-B' (Healy Equation 35).
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.CalculateIntegralTermN(System.Double,System.Double,System.Double[],System.Double[],System.Double)">
            <summary>
            Calculates integral term for numerator (r-weighted).
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.CalculateIntegralTermD(System.Double,System.Double,System.Double[],System.Double[],System.Double)">
            <summary>
            Calculates integral term for denominator (q-weighted).
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.FindCrossingTime(System.Double[],System.Double[])">
            <summary>
            Finds initial crossing time estimate.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Alaris.Double.DoubleBoundaryKimSolver.RefineCrossingTime(System.Double[],System.Double[],System.Double)" -->
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.AdjustCrossingInitialGuess(System.Double[],System.Double[],System.Double)">
            <summary>
            Adjusts initial guess when boundaries cross (Healy p.12).
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.EnforceConstraints(System.Double,System.Double,System.Double)">
            <summary>
            Enforces boundary constraints.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.InterpolateBoundary(System.Double[],System.Double)">
            <summary>
            Interpolates boundary value at given time.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.CalculateD1(System.Double,System.Double,System.Double)">
            <summary>
            Calculates d1 for Black-Scholes formula.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.CalculateD2(System.Double,System.Double,System.Double)">
            <summary>
            Calculates d2 for Black-Scholes formula.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.NormalCDF(System.Double)">
            <summary>
            Normal cumulative distribution function.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundaryKimSolver.Erf(System.Double)">
            <summary>
            Error function approximation.
            </summary>
        </member>
        <member name="T:Alaris.Double.DoubleBoundarySolver">
            <summary>
            Complete solver for American options with double boundaries under negative rates.
            Combines QD+ approximation with FP-B' stabilized Kim integral equation refinement.
            </summary>
            <remarks>
            <para>
            Two-stage solving process:
            1. QD+ approximation with Super Halley's method provides fast initial boundaries
            2. FP-B' stabilized Kim solver refines using fixed point iteration
            </para>
            <para>
            Architecture mirrors QuantLib's approach:
            - Single boundary (r ≥ 0): QdPlus → QdFp (Chebyshev)
            - Double boundary (q &lt; r &lt; 0): QdPlus → FP-B' Kim (collocation + stabilized fixed point)
            </para>
            <para>
            Key improvement: Uses FP-B' (Healy Equations 33-35) instead of basic FP-B to prevent
            oscillations in longer maturity options.
            </para>
            </remarks>
        </member>
        <member name="M:Alaris.Double.DoubleBoundarySolver.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Initializes the double boundary solver.
            </summary>
            <param name="spot">Current asset price</param>
            <param name="strike">Strike price</param>
            <param name="maturity">Time to maturity (years)</param>
            <param name="rate">Risk-free rate (negative for negative rate regime)</param>
            <param name="dividendYield">Dividend yield (negative for negative rate regime)</param>
            <param name="volatility">Volatility</param>
            <param name="isCall">True for call, false for put</param>
            <param name="collocationPoints">Number of time points (default 50)</param>
            <param name="useRefinement">Use FP-B' Kim refinement (default true)</param>
        </member>
        <member name="M:Alaris.Double.DoubleBoundarySolver.Solve">
            <summary>
            Solves for both boundaries using QD+ approximation and optional Kim refinement.
            </summary>
            <returns>Solution containing boundaries and metadata</returns>
        </member>
        <member name="M:Alaris.Double.DoubleBoundarySolver.DetectDoubleBoundaryRegime">
            <summary>
            Detects if the option is in a double boundary regime.
            </summary>
        </member>
        <member name="M:Alaris.Double.DoubleBoundarySolver.ValidateBoundaries(System.Double,System.Double)">
            <summary>
            Validates boundary values for consistency.
            </summary>
        </member>
        <member name="T:Alaris.Double.DoubleBoundaryResult">
            <summary>
            Result from double boundary solver.
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.UpperBoundary">
            <summary>
            Upper exercise boundary at maturity.
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.LowerBoundary">
            <summary>
            Lower exercise boundary at maturity.
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.CrossingTime">
            <summary>
            Time when boundaries cross (0 if no crossing).
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.IsRefined">
            <summary>
            Indicates if Kim refinement was applied.
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.Method">
            <summary>
            Method used for calculation.
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.IsValid">
            <summary>
            Indicates if boundaries are valid.
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.Iterations">
            <summary>
            Number of iterations or collocation points used.
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.QdUpperBoundary">
            <summary>
            QD+ upper boundary (before refinement).
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.QdLowerBoundary">
            <summary>
            QD+ lower boundary (before refinement).
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.UpperImprovement">
            <summary>
            Improvement from QD+ to refined (upper boundary).
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.LowerImprovement">
            <summary>
            Improvement from QD+ to refined (lower boundary).
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.UpperBoundaryPath">
            <summary>
            Optional: Full upper boundary path across time points.
            </summary>
        </member>
        <member name="P:Alaris.Double.DoubleBoundaryResult.LowerBoundaryPath">
            <summary>
            Optional: Full lower boundary path across time points.
            </summary>
        </member>
        <member name="T:Alaris.Double.QdPlusApproximation">
            <summary>
            QD+ approximation for American option boundaries under negative interest rates.
            Implements the complete mathematical framework from Healy (2021) without hard-coding.
            </summary>
            <remarks>
            <para>
            CRITICAL FIX: Corrected alpha and beta definitions to match Healy Equation 10:
            - α = 2r/σ² (not 0.5 - (r-q)/σ²)
            - β = 2(r-q)/σ² (not α² + 2r/σ²)
            </para>
            <para>
            The incorrect formulas caused the boundary equation to produce wrong c0 values,
            leading to convergence to S = 100 instead of the correct boundaries.
            </para>
            </remarks>
        </member>
        <member name="M:Alaris.Double.QdPlusApproximation.CalculateBoundaries">
            <summary>
            Calculates both upper and lower boundaries using QD+ approximation.
            </summary>
            <returns>Initial (Upper, Lower) boundary estimates for Kim solver refinement</returns>
        </member>
        <member name="M:Alaris.Double.QdPlusApproximation.CalculateDoubleBoundariesPut">
            <summary>
            Calculates double boundaries for put options in negative rate regime.
            </summary>
        </member>
        <member name="M:Alaris.Double.QdPlusApproximation.CalculateLambdaRoots(System.Double,System.Double,System.Double)">
            <summary>
            Calculates lambda roots for the characteristic equation.
            </summary>
        </member>
        <member name="M:Alaris.Double.QdPlusApproximation.SolveBoundaryEquation(System.Double,System.Double,System.Boolean)">
            <summary>
            Solves the QD+ boundary equation using Super Halley's method.
            CORRECTED VERSION: Uses relaxed constraints during iteration.
            </summary>
            <remarks>
            Implements Healy Equation 17 for robust third-order convergence.
            
            KEY FIX: The original implementation applied strict constraints (S ≤ strike - ε) 
            after each iteration, causing Super Halley to become trapped at the strike 
            price (100.0) instead of converging to the correct boundary (~69-73).
            
            This corrected version:
            1. Uses RELAXED bounds during iteration (0.01*K to 2.0*K)
            2. Applies STRICT constraints only after convergence
            3. Allows Super Halley to explore solution space properly
            </remarks>
        </member>
        <member name="M:Alaris.Double.QdPlusApproximation.EvaluateBoundaryFunction(System.Double,System.Double,System.Double)">
            <summary>
            Evaluates the QD+ boundary equation and its derivatives.
            </summary>
            <remarks>
            CRITICAL FIX: Corrected c0 calculation to use (1-h) consistently for all h.
            The formula (1-h) works correctly for both positive and negative h values.
            </remarks>
        </member>
        <member name="M:Alaris.Double.QdPlusApproximation.GetCalibratedInitialGuess(System.Boolean)">
            <summary>
            Calculates calibrated initial guess for negative rate regime.
            </summary>
            <remarks>
            Empirically calibrated formulas outperform asymptotic limits for
            avoiding convergence to wrong basins of attraction.
            </remarks>
        </member>
        <member name="M:Alaris.Double.QdPlusApproximation.ApproximateForSmallH">
            <summary>
            Approximates boundaries when h is very small (r ≈ 0).
            </summary>
        </member>
        <member name="M:Alaris.Double.QdPlusApproximation.ApproximateEmpiricalBoundaries">
            <summary>
            Provides empirical approximation when exact calculation fails.
            </summary>
        </member>
        <member name="M:Alaris.Double.QdPlusApproximation.CalculateComplexLambdaApproximation(System.Double)">
            <summary>
            Handles complex lambda roots using approximation.
            </summary>
        </member>
        <member name="M:Alaris.Double.QdPlusApproximation.CalculateSingleBoundaryPut">
            <summary>
            Calculates single boundary for standard put (r ≥ 0).
            </summary>
        </member>
        <member name="M:Alaris.Double.QdPlusApproximation.CalculateSingleBoundaryCall">
            <summary>
            Calculates single boundary for standard call (q ≥ 0).
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Alaris.Double.QdPlusApproximation.CalculateDoubleBoundariesCall" -->
        <member name="M:Alaris.Double.QdPlusApproximation.CalculateThetaBS(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Calculates Black-Scholes theta with correct sign convention.
            </summary>
        </member>
        <member name="M:Alaris.Double.QdPlusApproximation.CalculateLambdaPrime(System.Double,System.Double,System.Double)">
            <summary>
            Calculates lambda derivative with respect to h.
            </summary>
        </member>
        <member name="M:Alaris.Double.QdPlusApproximation.CalculateDc0DS(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Calculates derivative of c0 with respect to S.
            </summary>
        </member>
        <member name="M:Alaris.Double.QdPlusApproximation.NormalCDF(System.Double)">
            <summary>
            Normal cumulative distribution function.
            </summary>
        </member>
        <member name="M:Alaris.Double.QdPlusApproximation.NormalPDF(System.Double)">
            <summary>
            Normal probability density function.
            </summary>
        </member>
        <member name="M:Alaris.Double.QdPlusApproximation.Erf(System.Double)">
            <summary>
            Error function approximation.
            </summary>
        </member>
    </members>
</doc>
