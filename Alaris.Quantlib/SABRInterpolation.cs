//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (https://www.swig.org).
// Version 4.2.0
//
// Do not make changes to this file unless you know what you are doing - modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------


public class SABRInterpolation : global::System.IDisposable {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  protected bool swigCMemOwn;

  internal SABRInterpolation(global::System.IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(SABRInterpolation obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  internal static global::System.Runtime.InteropServices.HandleRef swigRelease(SABRInterpolation obj) {
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new global::System.ApplicationException("Cannot release ownership as memory is not owned");
      global::System.Runtime.InteropServices.HandleRef ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.Dispose();
      return ptr;
    } else {
      return new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
    }
  }

  ~SABRInterpolation() {
    Dispose(false);
  }

  public void Dispose() {
    Dispose(true);
    global::System.GC.SuppressFinalize(this);
  }

  protected virtual void Dispose(bool disposing) {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          NQuantLibcPINVOKE.delete_SABRInterpolation(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
    }
  }

  public SABRInterpolation(QlArray strikes, QlArray volatilities, double expiryTime, double forward, double alpha, double beta, double nu, double rho, bool alphaIsFixed, bool betaIsFixed, bool nuIsFixed, bool rhoIsFixed, bool vegaWeighted, EndCriteria endCriteria, OptimizationMethod optMethod, double errorAccept, bool useMaxError, uint maxGuesses, double shift, VolatilityType volatilityType) : this(NQuantLibcPINVOKE.new_SABRInterpolation__SWIG_0(QlArray.getCPtr(strikes), QlArray.getCPtr(volatilities), expiryTime, forward, alpha, beta, nu, rho, alphaIsFixed, betaIsFixed, nuIsFixed, rhoIsFixed, vegaWeighted, EndCriteria.getCPtr(endCriteria), OptimizationMethod.getCPtr(optMethod), errorAccept, useMaxError, maxGuesses, shift, (int)volatilityType), true) {
    if (NQuantLibcPINVOKE.SWIGPendingException.Pending) throw NQuantLibcPINVOKE.SWIGPendingException.Retrieve();
  }

  public SABRInterpolation(QlArray strikes, QlArray volatilities, double expiryTime, double forward, double alpha, double beta, double nu, double rho, bool alphaIsFixed, bool betaIsFixed, bool nuIsFixed, bool rhoIsFixed, bool vegaWeighted, EndCriteria endCriteria, OptimizationMethod optMethod, double errorAccept, bool useMaxError, uint maxGuesses, double shift) : this(NQuantLibcPINVOKE.new_SABRInterpolation__SWIG_1(QlArray.getCPtr(strikes), QlArray.getCPtr(volatilities), expiryTime, forward, alpha, beta, nu, rho, alphaIsFixed, betaIsFixed, nuIsFixed, rhoIsFixed, vegaWeighted, EndCriteria.getCPtr(endCriteria), OptimizationMethod.getCPtr(optMethod), errorAccept, useMaxError, maxGuesses, shift), true) {
    if (NQuantLibcPINVOKE.SWIGPendingException.Pending) throw NQuantLibcPINVOKE.SWIGPendingException.Retrieve();
  }

  public SABRInterpolation(QlArray strikes, QlArray volatilities, double expiryTime, double forward, double alpha, double beta, double nu, double rho, bool alphaIsFixed, bool betaIsFixed, bool nuIsFixed, bool rhoIsFixed, bool vegaWeighted, EndCriteria endCriteria, OptimizationMethod optMethod, double errorAccept, bool useMaxError, uint maxGuesses) : this(NQuantLibcPINVOKE.new_SABRInterpolation__SWIG_2(QlArray.getCPtr(strikes), QlArray.getCPtr(volatilities), expiryTime, forward, alpha, beta, nu, rho, alphaIsFixed, betaIsFixed, nuIsFixed, rhoIsFixed, vegaWeighted, EndCriteria.getCPtr(endCriteria), OptimizationMethod.getCPtr(optMethod), errorAccept, useMaxError, maxGuesses), true) {
    if (NQuantLibcPINVOKE.SWIGPendingException.Pending) throw NQuantLibcPINVOKE.SWIGPendingException.Retrieve();
  }

  public SABRInterpolation(QlArray strikes, QlArray volatilities, double expiryTime, double forward, double alpha, double beta, double nu, double rho, bool alphaIsFixed, bool betaIsFixed, bool nuIsFixed, bool rhoIsFixed, bool vegaWeighted, EndCriteria endCriteria, OptimizationMethod optMethod, double errorAccept, bool useMaxError) : this(NQuantLibcPINVOKE.new_SABRInterpolation__SWIG_3(QlArray.getCPtr(strikes), QlArray.getCPtr(volatilities), expiryTime, forward, alpha, beta, nu, rho, alphaIsFixed, betaIsFixed, nuIsFixed, rhoIsFixed, vegaWeighted, EndCriteria.getCPtr(endCriteria), OptimizationMethod.getCPtr(optMethod), errorAccept, useMaxError), true) {
    if (NQuantLibcPINVOKE.SWIGPendingException.Pending) throw NQuantLibcPINVOKE.SWIGPendingException.Retrieve();
  }

  public SABRInterpolation(QlArray strikes, QlArray volatilities, double expiryTime, double forward, double alpha, double beta, double nu, double rho, bool alphaIsFixed, bool betaIsFixed, bool nuIsFixed, bool rhoIsFixed, bool vegaWeighted, EndCriteria endCriteria, OptimizationMethod optMethod, double errorAccept) : this(NQuantLibcPINVOKE.new_SABRInterpolation__SWIG_4(QlArray.getCPtr(strikes), QlArray.getCPtr(volatilities), expiryTime, forward, alpha, beta, nu, rho, alphaIsFixed, betaIsFixed, nuIsFixed, rhoIsFixed, vegaWeighted, EndCriteria.getCPtr(endCriteria), OptimizationMethod.getCPtr(optMethod), errorAccept), true) {
    if (NQuantLibcPINVOKE.SWIGPendingException.Pending) throw NQuantLibcPINVOKE.SWIGPendingException.Retrieve();
  }

  public SABRInterpolation(QlArray strikes, QlArray volatilities, double expiryTime, double forward, double alpha, double beta, double nu, double rho, bool alphaIsFixed, bool betaIsFixed, bool nuIsFixed, bool rhoIsFixed, bool vegaWeighted, EndCriteria endCriteria, OptimizationMethod optMethod) : this(NQuantLibcPINVOKE.new_SABRInterpolation__SWIG_5(QlArray.getCPtr(strikes), QlArray.getCPtr(volatilities), expiryTime, forward, alpha, beta, nu, rho, alphaIsFixed, betaIsFixed, nuIsFixed, rhoIsFixed, vegaWeighted, EndCriteria.getCPtr(endCriteria), OptimizationMethod.getCPtr(optMethod)), true) {
    if (NQuantLibcPINVOKE.SWIGPendingException.Pending) throw NQuantLibcPINVOKE.SWIGPendingException.Retrieve();
  }

  public SABRInterpolation(QlArray strikes, QlArray volatilities, double expiryTime, double forward, double alpha, double beta, double nu, double rho, bool alphaIsFixed, bool betaIsFixed, bool nuIsFixed, bool rhoIsFixed, bool vegaWeighted, EndCriteria endCriteria) : this(NQuantLibcPINVOKE.new_SABRInterpolation__SWIG_6(QlArray.getCPtr(strikes), QlArray.getCPtr(volatilities), expiryTime, forward, alpha, beta, nu, rho, alphaIsFixed, betaIsFixed, nuIsFixed, rhoIsFixed, vegaWeighted, EndCriteria.getCPtr(endCriteria)), true) {
    if (NQuantLibcPINVOKE.SWIGPendingException.Pending) throw NQuantLibcPINVOKE.SWIGPendingException.Retrieve();
  }

  public SABRInterpolation(QlArray strikes, QlArray volatilities, double expiryTime, double forward, double alpha, double beta, double nu, double rho, bool alphaIsFixed, bool betaIsFixed, bool nuIsFixed, bool rhoIsFixed, bool vegaWeighted) : this(NQuantLibcPINVOKE.new_SABRInterpolation__SWIG_7(QlArray.getCPtr(strikes), QlArray.getCPtr(volatilities), expiryTime, forward, alpha, beta, nu, rho, alphaIsFixed, betaIsFixed, nuIsFixed, rhoIsFixed, vegaWeighted), true) {
    if (NQuantLibcPINVOKE.SWIGPendingException.Pending) throw NQuantLibcPINVOKE.SWIGPendingException.Retrieve();
  }

  public SABRInterpolation(QlArray strikes, QlArray volatilities, double expiryTime, double forward, double alpha, double beta, double nu, double rho, bool alphaIsFixed, bool betaIsFixed, bool nuIsFixed, bool rhoIsFixed) : this(NQuantLibcPINVOKE.new_SABRInterpolation__SWIG_8(QlArray.getCPtr(strikes), QlArray.getCPtr(volatilities), expiryTime, forward, alpha, beta, nu, rho, alphaIsFixed, betaIsFixed, nuIsFixed, rhoIsFixed), true) {
    if (NQuantLibcPINVOKE.SWIGPendingException.Pending) throw NQuantLibcPINVOKE.SWIGPendingException.Retrieve();
  }

  public SABRInterpolation(QlArray strikes, QlArray volatilities, double expiryTime, double forward, double alpha, double beta, double nu, double rho, bool alphaIsFixed, bool betaIsFixed, bool nuIsFixed) : this(NQuantLibcPINVOKE.new_SABRInterpolation__SWIG_9(QlArray.getCPtr(strikes), QlArray.getCPtr(volatilities), expiryTime, forward, alpha, beta, nu, rho, alphaIsFixed, betaIsFixed, nuIsFixed), true) {
    if (NQuantLibcPINVOKE.SWIGPendingException.Pending) throw NQuantLibcPINVOKE.SWIGPendingException.Retrieve();
  }

  public SABRInterpolation(QlArray strikes, QlArray volatilities, double expiryTime, double forward, double alpha, double beta, double nu, double rho, bool alphaIsFixed, bool betaIsFixed) : this(NQuantLibcPINVOKE.new_SABRInterpolation__SWIG_10(QlArray.getCPtr(strikes), QlArray.getCPtr(volatilities), expiryTime, forward, alpha, beta, nu, rho, alphaIsFixed, betaIsFixed), true) {
    if (NQuantLibcPINVOKE.SWIGPendingException.Pending) throw NQuantLibcPINVOKE.SWIGPendingException.Retrieve();
  }

  public SABRInterpolation(QlArray strikes, QlArray volatilities, double expiryTime, double forward, double alpha, double beta, double nu, double rho, bool alphaIsFixed) : this(NQuantLibcPINVOKE.new_SABRInterpolation__SWIG_11(QlArray.getCPtr(strikes), QlArray.getCPtr(volatilities), expiryTime, forward, alpha, beta, nu, rho, alphaIsFixed), true) {
    if (NQuantLibcPINVOKE.SWIGPendingException.Pending) throw NQuantLibcPINVOKE.SWIGPendingException.Retrieve();
  }

  public SABRInterpolation(QlArray strikes, QlArray volatilities, double expiryTime, double forward, double alpha, double beta, double nu, double rho) : this(NQuantLibcPINVOKE.new_SABRInterpolation__SWIG_12(QlArray.getCPtr(strikes), QlArray.getCPtr(volatilities), expiryTime, forward, alpha, beta, nu, rho), true) {
    if (NQuantLibcPINVOKE.SWIGPendingException.Pending) throw NQuantLibcPINVOKE.SWIGPendingException.Retrieve();
  }

  public double call(double x, bool allowExtrapolation) {
    double ret = NQuantLibcPINVOKE.SABRInterpolation_call__SWIG_0(swigCPtr, x, allowExtrapolation);
    if (NQuantLibcPINVOKE.SWIGPendingException.Pending) throw NQuantLibcPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public double call(double x) {
    double ret = NQuantLibcPINVOKE.SABRInterpolation_call__SWIG_1(swigCPtr, x);
    if (NQuantLibcPINVOKE.SWIGPendingException.Pending) throw NQuantLibcPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public double alpha() {
    double ret = NQuantLibcPINVOKE.SABRInterpolation_alpha(swigCPtr);
    if (NQuantLibcPINVOKE.SWIGPendingException.Pending) throw NQuantLibcPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public double beta() {
    double ret = NQuantLibcPINVOKE.SABRInterpolation_beta(swigCPtr);
    if (NQuantLibcPINVOKE.SWIGPendingException.Pending) throw NQuantLibcPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public double rho() {
    double ret = NQuantLibcPINVOKE.SABRInterpolation_rho(swigCPtr);
    if (NQuantLibcPINVOKE.SWIGPendingException.Pending) throw NQuantLibcPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public double nu() {
    double ret = NQuantLibcPINVOKE.SABRInterpolation_nu(swigCPtr);
    if (NQuantLibcPINVOKE.SWIGPendingException.Pending) throw NQuantLibcPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

}
