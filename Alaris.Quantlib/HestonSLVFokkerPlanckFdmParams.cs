//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (https://www.swig.org).
// Version 4.2.0
//
// Do not make changes to this file unless you know what you are doing - modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------


public class HestonSLVFokkerPlanckFdmParams : global::System.IDisposable {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  protected bool swigCMemOwn;

  internal HestonSLVFokkerPlanckFdmParams(global::System.IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(HestonSLVFokkerPlanckFdmParams obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  internal static global::System.Runtime.InteropServices.HandleRef swigRelease(HestonSLVFokkerPlanckFdmParams obj) {
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new global::System.ApplicationException("Cannot release ownership as memory is not owned");
      global::System.Runtime.InteropServices.HandleRef ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.Dispose();
      return ptr;
    } else {
      return new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
    }
  }

  ~HestonSLVFokkerPlanckFdmParams() {
    Dispose(false);
  }

  public void Dispose() {
    Dispose(true);
    global::System.GC.SuppressFinalize(this);
  }

  protected virtual void Dispose(bool disposing) {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          NQuantLibcPINVOKE.delete_HestonSLVFokkerPlanckFdmParams(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
    }
  }

  public HestonSLVFokkerPlanckFdmParams(uint xGrid, uint vGrid, uint tMaxStepsPerYear, uint tMinStepsPerYear, double tStepNumberDecay, uint nRannacherTimeSteps, uint predictionCorretionSteps, double x0Density, double localVolEpsProb, uint maxIntegrationIterations, double vLowerEps, double vUpperEps, double vMin, double v0Density, double vLowerBoundDensity, double vUpperBoundDensity, double leverageFctPropEps, FdmHestonGreensFct.Algorithm greensAlgorithm, FdmSquareRootFwdOp.TransformationType trafoType, FdmSchemeDesc schemeDesc) : this(NQuantLibcPINVOKE.new_HestonSLVFokkerPlanckFdmParams(xGrid, vGrid, tMaxStepsPerYear, tMinStepsPerYear, tStepNumberDecay, nRannacherTimeSteps, predictionCorretionSteps, x0Density, localVolEpsProb, maxIntegrationIterations, vLowerEps, vUpperEps, vMin, v0Density, vLowerBoundDensity, vUpperBoundDensity, leverageFctPropEps, (int)greensAlgorithm, (int)trafoType, FdmSchemeDesc.getCPtr(schemeDesc)), true) {
    if (NQuantLibcPINVOKE.SWIGPendingException.Pending) throw NQuantLibcPINVOKE.SWIGPendingException.Retrieve();
  }

}
